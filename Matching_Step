import pandas as pd
import numpy as np
from datetime import datetime

## for the different requirments from the customers, it will use the vectorized matching method. 
## The left side is the user requirements, including the group size, 

# def count_stay_days(start_date: str, end_date: str, fmt: str = "%Y-%m-%d") -> int:
#   d1 = datetime.strptime(start_date, fmt)
#   d2 = datetime.strptime(end_date, fmt)
#    delta = d2 - d1
#    return delta.days


m_begin = datetime.strptime("2025-01-01", "%Y-%m-%d")
m_end = datetime.strptime("2025-01-31", "%Y-%m-%d")

print(m_begin)
print(m_end)


def match_step(dataframe, user):
    df = df.copy()

    # get the data
    user_data = user["data"][0]

    # Price data transfer
    min_budget = user_data["min_budget"]
    max_budget = user.budget["max_budget"]
    price_of_property = dataframe["Nightly price"]

    # Location data transfer
    pro_location = dataframe["City"]
    user_location = user_data["location"]

    # Environment data transfer
    user_environment = user_data["preferred_environment"]

    # Scoring for price
    if min_budget is not None or max_budget is not None:
        # Score = 1 inside [min_price, max_price]; taper to 0 outside by 25%
        lo_bound = -np.inf if min_budget is None else float(min_budget)
        hi_bound =  np.inf if max_budget is None else float(max_budget)
        inside = (price_of_property >= lo_bound) & (price_of_property <= hi_bound)
        # distance to nearest bound normalized by a soft band = 0.25 * (hi if finite else price)
        # If both bounds are infinite (shouldn't happen), fall back to zeros.
        soft = np.where(np.isfinite(hi_bound), 0.25 * hi_bound, np.maximum(0.25 * price_of_property, 1.0))
        dist  = np.where(price_of_property < lo_bound, (lo_bound - price_of_property) / np.maximum(soft, 1e-6),
                 np.where(price_of_property > hi_bound, (price_of_property - hi_bound) / np.maximum(soft, 1e-6), 0.0))
        price_score = np.clip(1.0 - dist, 0.0, 1.0)
        price_score[inside] = 1.0

    else:
        price_score = np.ones(len(dataframe), dtype = float)

    # Scoring for Location

    if 




